### Запуск проекта в docker-compose (HW15)

`make up-build` запуск с принудительной сборкой контейнеров

`make up` простой запуск

_REST-API, согласно заданию, транслируется на 8888 порт, в отличие от локального запуска проекта из HW14_

_GRPC-API транслируется на 8889 порт_

### Остановка проекта в docker-compose (HW15)

`make down`

### Запуск интеграционных тестов (HW15)

`make integration-tests-build` сборка контейнеров для прогона тестов (без запуска тестов)

`make integration-tests` запуск тестов

---

### Запуск проекта локально (HW14)
1) `make run_db` запускает контейнер с БД, пытается создать схему и добавить пользователя
2) `make migrate` устанавливает `goose`, выполняет миграции
3) `make run_mq` запускает контейнер с RabbitMQ
4) `make run_scheduler` запускает планировщик
5) `make run_sender` запускает рассыльщик
6) `make run` запускает серверы апи

### Остановка проекта локально (HW14)
1) `^С` в терминалах с `calendar`, `sender`, `scheduler`
2) `make stop_db` останавливает и удаляет контейнер с БД
3) `make stop_mq` останавливает и удаляет контейнер с RabbitMQ

### Проверка работы планировщика и рассыльщика (HW14)

На примере REST-api
1) Создаём событие c датой старта в будущем и настройкой оповещения тоже в будущем

   (не забываем запомнить значение поля ID в ответе метода)
    ```
    curl -X POST -H "X-API-User: 12cfff04-ed0a-49f5-9b1e-216512ca3aa8" -d '{"Title":"First event", "StartDate":"2023-11-01 10:00:00", "EndDate":"2023-11-01 11:00:00", "Description":"", "NotifyBefore":"24h"}' http://localhost:8081/event
    ```
    Нотификации пока быть не должно.
    В моём случае ID события в ответе было 438b6f90-3af1-4838-9342-57c30c410718


2) Проверяем, что событие возвращается
    ```
    curl -X GET -H "X-API-User: 12cfff04-ed0a-49f5-9b1e-216512ca3aa8" http://localhost:8081/event/438b6f90-3af1-4838-9342-57c30c410718
    ```

3) Меняем период нотификации таким образом, чтобы время нотификации получилось в прошлом. Я поменял на 1000 дней до события.

    > Для обновления необходимо передать все поля события, иначе они перетрутся нуль-значениями. Да, не очень удобно, но для учебных целей, считаю достаточным. При наличии большего кол-ва свободного времени я бы переделал это по крайней мере для REST-api и обновлял бы только переданные поля. Для GRPC-api так сделать не получится, т.к. там, насколько я понял, нельзя отличить не переданные поля от переданных. Поэтому сейчас оба апи ведут себя одинаково.
    ```
    curl -X POST -H "X-API-User: 12cfff04-ed0a-49f5-9b1e-216512ca3aa8" -d '{"Title":"First event", "StartDate":"2023-11-01 10:00:00", "EndDate":"2023-11-01 11:00:00", "Description":"", "NotifyBefore":"24000h"}' http://localhost:8081/event/438b6f90-3af1-4838-9342-57c30c410718
    ```
    Должно отправиться уведомление. Проверяем это с помощью логов планировщика и рассыльщика. Планировщик запускается раз в минуту (настраивается в конфиге).


4) Сдвигаем даты события на пару лет назад.
    ```
    curl -X POST -H "X-API-User: 12cfff04-ed0a-49f5-9b1e-216512ca3aa8" -d '{"Title":"First event", "StartDate":"2021-11-01 10:00:00", "EndDate":"2021-11-01 11:00:00", "Description":"", "NotifyBefore":"24000h"}' http://localhost:8081/event/438b6f90-3af1-4838-9342-57c30c410718
    ```
    Планировщик должен удалить событие. Смотрим в лог планировщика. Планировщик запускается раз в минуту (настраивается в конфиге).


5) Проверяем, что событие удалено
    ```
    curl -X GET -H "X-API-User: 12cfff04-ed0a-49f5-9b1e-216512ca3aa8" http://localhost:8081/event/438b6f90-3af1-4838-9342-57c30c410718
    ```
---

#### Результатом выполнения следующих домашних заданий является сервис «Календарь»:
- [Домашнее задание №12 «Заготовка сервиса Календарь»](./docs/12_README.md)
- [Домашнее задание №13 «Внешние API от Календаря»](./docs/13_README.md)
- [Домашнее задание №14 «Кроликизация Календаря»](./docs/14_README.md)
- [Домашнее задание №15 «Докеризация и интеграционное тестирование Календаря»](./docs/15_README.md)

#### Ветки при выполнении
- `hw12_calendar` (от `master`) -> Merge Request в `master`
- `hw13_calendar` (от `hw12_calendar`) -> Merge Request в `hw12_calendar` (если уже вмержена, то в `master`)
- `hw14_calendar` (от `hw13_calendar`) -> Merge Request в `hw13_calendar` (если уже вмержена, то в `master`)
- `hw15_calendar` (от `hw14_calendar`) -> Merge Request в `hw14_calendar` (если уже вмержена, то в `master`)

**Домашнее задание не принимается, если не принято ДЗ, предшедствующее ему.**
