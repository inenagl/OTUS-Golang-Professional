package hw06pipelineexecution

type (
	In  = <-chan interface{}
	Out = In
	Bi  = chan interface{}
)

type Stage func(in In) (out Out)

func ExecutePipeline(in In, done In, stages ...Stage) Out {
	if in == nil {
		result := make(Bi)
		close(result)
		return result
	} else if len(stages) == 0 {
		return in
	}

	// Т.к. мы не можем контролировать внутреннюю горутину каждой стадии пайплайна (я не нашёл такой возможности),
	// то для того, чтобы получить возможнось прерывания работы пайплайна встроимся в точку передачи данных
	// между его стадиями. Поэтому мы не будем использовать выходной канал предыдущей стадии напрямую в качестве
	// входного для текущей стадии, а переложим данные из него в новый канал, который и подадим на вход следующей стадии.
	// В точке перекладывания мы сможем дополнительно обработать сигнал на остановку работы пайплайна
	// и прервать выполнение, закрыв входные каналы стадий пайплайна.
	out := in
	for _, stage := range stages {
		// Оборачиваем вызов стадии пайплайна в функцию, которая будет перекладывать результаты предыдущей стадии
		// в новый канал
		out = func(stage Stage, in In) Out {
			ch := make(Bi)
			go func() {
				defer close(ch)

				// Здесь слушаем либо событие остановки пайплайна либо читаем выходной канал предыдущей стадии (который
				// должен был бы быть входным для текущей стадии)
				for {
					select {
					case <-done:
						return
					case v, ok := <-in:
						if !ok {
							return
						}
						ch <- v
					}
				}
			}()

			// Новый канал передаём в качестве входного в текущую стадию
			return stage(ch)
		}(stage, out)
	}

	return out
}
